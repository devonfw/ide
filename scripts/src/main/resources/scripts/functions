#!/usr/bin/env bash
if [ -n "${DEVON_IDE_TRACE}" ]; then set -vx; fi
# Functions to be reused in devonfw-ide commands. Will actually be sourced,
# hash bang only for filetype detection and editor syntax support

if [ -z "${DEVON_IDE_HOME}" ]
then
  cd "$(dirname "${BASH_SOURCE:-$0}")/.." || exit 1
  DEVON_IDE_HOME="${PWD}"
  cd - > /dev/null || exit 1
  echo "DEVON_IDE_HOME variable set to ${DEVON_IDE_HOME}"
fi

# shellcheck source=scripts/functions-core
source "${DEVON_IDE_HOME}/scripts/functions-core"

# $1: message (may contain newlines with \n)
# $2: optional exit code
function doFail() {
  doEchoAttention ""
  doError "${1}\nWe are sorry for the inconvenience. Please check the above errors, resolve them and try again."
  if [ -n "${2}" ]
  then
    doError "Exit code was ${2}"
    if [ "${2}" = "0" ]
    then
      exit 1
    fi
    exit "${2}"
  else
    exit 255
  fi
}

function doEchoAttention() {
  echo
  doWarning "******** ATTENTION ********"
  if [ -n "${1}" ]
  then
    doWarning "${@}"
  fi
}

# $1: message
# $2: exit code
function doResult() {
  if [ "${2}" = 0 ]
  then
    doSuccess "Success: ${1}"
  else
    if [ -z "${2}" ]
    then
      doFail "Failed to ${1} (internal error missing exit code)"
    else
      doFail "Failed to ${1}" "${2}"
    fi
  fi
}

# $1: command
# $2: message
# $3: optional working directory
function doRunCommand() {
  local command="${1}"
  local message="${2}"
  local dir="${3}"
  if [ -n "${dir}" ]
  then
    if [ -d "${dir}" ]
    then
      pushd "${dir}" > /dev/null || exit 255
    else
      doFail "Working directory ${3} does not exist."
    fi
  fi
  if [ -z "${message}" ]
  then
    doDebug "Trying to run command ${command}"
    message="run command ${command/ */}"
  else
    doDebug "Trying to ${message} (${command})"
    message="${message} (${command/ */})"
  fi
  eval "${command}"
  result=${?}
  if [ -n "${dir}" ]
  then
    popd > /dev/null || exit 255 
  fi
  doResult "${message}" "${result}"
}

function doIsForce() {
  # shellcheck disable=SC2154
  [ -n "${force}" ]
  return
}

function doIsBatch() {
  # shellcheck disable=SC2154
  [ -n "${batch}" ] || [ "${CI}" = "true" ]
  return
}

function doRequireNotBatch() {
  if doIsBatch
  then
    doFail "Cannot proceed in batch mode as interactive installation is required. Please rerun without batch option."
  fi
}

function doIsQuiet() {
  # shellcheck disable=SC2154
  [ -n "${quiet}" ]
  return
}

function doIsDebug() {
  # shellcheck disable=SC2154
  [ -n "${debug}" ] && [ -z "${quiet}" ]
  return
}

# $1: basename of folder
function doIsIgnoredFolder() {
  case "${1}" in
   target)
     return;;
   eclipse-target)
     return;;
   node_modules)
     return;;
   .git)
     return;;
   .svn)
     return;;
  esac
  return 255
}

# $@: messages to output
function doEcho() {
  if doIsQuiet
  then
    return
  fi
  echo -e "${@}"
}

# $@: messages to output
function doInfo() {
  echo -e "\033[34m${*}\033[39m"
}

# $@: messages to output
function doEchoStep() {
  echo -e "\n\033[35m*** ${*} ***\033[39m"
}

# $@: messages to output
function doEchoOption() {
  echo -e "\033[96m${*}\033[39m"
}

# $@: success message
function doEchoInteraction() {
  echo -e "\033[96m${*}\033[39m"
}

# $1: first_range_version
# $2: version
# $3: last_range_version
# returns 0 if first_range_version <= version <= last_range_version
function doCheckVersionRange() {
  local first_range_version="${1}"
  local version="${2}"
  local last_range_version="${3}"
  doVersionCompare "${first_range_version}" "${version}" 
  check1="${?}"
  doVersionCompare "${version}" "${last_range_version}" 
  check2="${?}"
  if [ "${check1}" != "1" ] && [ "${check2}" != "1" ] 
  then
    return 0
  else 
    return 1
  fi
}

# $1: software
# $2: version
# $3: edition
function doCheckSoftwareSecurityVersion() {
  local software="${1}"
  local version="${2}"
  local edition="${3}"
  local security_file
  local check="0"
  local line=""
  local first_version
  local last_version
  local software_info="${software}"
  if [ -z "${edition}" ]
  then
    edition="${software}"
  fi
  security_file="${DEVON_IDE_HOME}/urls/${software}/${edition}/security"
  if [ -f "${security_file}" ]
  then
    while IFS= read -r line
    do
      first_version="$(echo "${line}" | cut -d'>' -f 1)"
      last_version="$(echo "${line}" | cut -d'>' -f 2)"
      doCheckVersionRange "${first_version}" "${version}" "${last_version}"
      if [ "${?}" == "0" ]
      then
        check="1"
      fi
    done < "${security_file}"
    if [ "${check}" == "1" ]
    then
      if [ "${edition}" != "${software}" ]
      then
        software_info="${software} with edition ${edition}"
      fi
      doReportVersionSecurityWarning "You are using the tool ${software_info} in version ${version} that has vulnerabilities. Please update the tool to state safe and secure.\nFor further details and recent information have a look at the following webpage:\nhttps://github.com/devonfw/ide/blob/master/documentation/vulnerabilities.asciidoc\n\n"
    fi
  fi
}

# $1: message
function doReportVersionSecurityWarning() {
  local message="${1}"
  doWarning "${message}"
}

function doDebug() {
  if ! doIsDebug
  then
    return
  fi
  echo -e "\033[90m${*}\033[39m"
}

# $@: warning message
function doWarning() {
  echo -e "\033[93m${*}\033[39m"
}

# $@: messages to output
function doError() {
  echo -e "\033[91m${1}\033[39m"
}

# $@: success message
function doSuccess() {
  echo -e "\033[92m${*}\033[39m"
}

# $@: success message
function doQuestion() {
  doEchoInteraction "${@}"
}

# $@: warning message
function doConfirmWarning() {
  doWarning "${@}"
  echo
  doAskToContinue ""
}

# $1: optional question
# $2: if 'return' will return with 255 otherwise exit if not continued
function doAskToContinue() {
  local question="Do you want to continue? "
  if [ -n "${1}" ]
  then
    question="${1}"
  fi
  if [ -n "${force}" ] || [ -n "${batch}" ]
  then
    doQuestion "${question}"
    doEcho "Yes (batch/force)"
    return
  fi
  local answer
  while true
  do
    doQuestion "${question}"
    read -r -p "(yes/no): " answer
    if [ "${answer}" = "yes" ] || [ -z "${answer}" ]
    then
      return
    elif [ "${answer}" = "no" ]
    then
      doEcho "No..."
      if [ "${2}" = "return" ]
      then
        return 255
      else
        exit 255
      fi
    else
      doQuestion "Please answer yes or no (or hit return for yes)."
    fi
  done
}

function doLogo() {
  local logo=(
"     ..........  ///                                                                                                   "
"    ..........  /////                  dd                                                      fffff                   "
"   ..........  ////////               ddd                                                     ffffff                   "
"  ..........  //////////              ddd                                                     ff                       "
" ..........    //////////        dddddddd   eeeeeee  vvv         vvv   oooo      nnnnnn     fffffff ww               ww"
"..........      //////////     dddddddddd  eeeeeeeeee vvv       vvv oooooooooo  nnnnnnnnnn  fffffff  ww      w      ww "
"..........       //////////   dddd    ddd eeee    eee  vvv     vvv oooo    oooo nnn     nnn   ff      ww    www    ww  "
"..........      //////////    ddd     ddd eeeeeeeeeee   vvv   vvv  ooo      ooo nnn      nnn  ff       ww  wwwww  ww   "
" ..........    //////////     ddd     ddd eeeeeeeeeee    vvvvvvv   ooo      ooo nnn      nnn  ff        ww wwwww ww    "
"  ..........  //////////       ddd    ddd eeee            vvvvv     ooo    ooo  nnn      nnn  ff         wwww wwww     "
"   ........  //////////         dddddddd   eeeeeeeeee      vvv       oooooooo   nnn      nnn  ff          ww   ww      "
"     .....  //////////            ddddd      eeeeee         v          oooo     nnn      nnn  ff           w   w       "
"      ...  //////////                                                                                                  "
  )
  local len
  len="$(tput cols)"
  if [ "$?" != 0 ]
  then
    len=80
  fi
  if [ "${len}" -gt 120 ]
  then
    len=120
  fi
  for ((i=0; i<${#logo[*]}; i=i+1))
  do
    echo "${logo[${i}]:0:$len}"
  done
}

# $1: file or URL to open
function doOpen() {
  if [ "${OSTYPE}" = "cygwin" ]
  then
    cygstart "${@}"
  elif [ "${OSTYPE}" = "msys" ]
  then
    start "${@}"
  else
    open "${@}"
  fi
}

function doLicenseAgreement() {
  if ! [ -f "${DEVON_HOME_DIR}/.devon/.license.agreement" ]
  then
    echo
    doLogo
    echo
    echo "Welcome to devonfw-ide!"
    echo "This product and its 3rd party components is open-source software and can be used free (also commercially)."
    echo "However, before using it you need to read the license agreement with all involved licenses agreements."
    echo "With confirming you take notice and agree that there is no warranty for using this product and its 3rd party components."
    echo "You are solely responsible for all risk implied by using this software."
    echo "You will be able to find it in one of the following locations:"
    echo "https://github.com/devonfw/ide/blob/master/documentation/LICENSE.asciidoc"
    echo "Also it is included in ${DEVON_IDE_HOME}/devon-ide-doc.pdf"
    echo
    if ! doIsBatch
    then
      doOpen "https://github.com/devonfw/ide/blob/master/documentation/LICENSE.asciidoc"
    fi
    if doIsBatch
    then
      doFail "You need to accept these terms of use and all license agreements. Please rerun in interactive (non-batch) mode."
    fi
    if doAskToContinue "Do you accept these terms of use and all license agreements?" "return"
    then
      echo -e "On $(date +"%Y-%m-%d") at $(date +"%H:%M:%S") you accepted the devonfw-ide License.\nhttps://github.com/devonfw/ide/blob/master/documentation/LICENSE.asciidoc" > "${DEVON_HOME_DIR}/.devon/.license.agreement"      
    else
      exit 255
    fi
    echo
  fi
}

# ${1}: devon command name
# ${n+1}: additional args
function doDevonCommand() {
  doDevonCommandAndReturn "${@}"
  result=${?}
  if [ ${result} != 0 ]
  then
    doFail "Failed to run devon ${*}" "${result}"
  else
    doUpdatePath
  fi
}

function doDevonCommandAllWorkspaces() {
  cd "${DEVON_IDE_HOME}/workspaces" || exit 1
  for file in *
  do
    if [ -d "${file}" ]
    then
      cd "${file}" || exit 1
      doEcho "Repeating command ${*} in workspace ${PWD}"
      "${DEVON_IDE_HOME}/scripts/devon" "${@}"
      cd .. || exit 1
    elif [ "${file}" != "readme.txt" ]
    then
      doWarning "The workspaces should only contain folder but ${file} is not"
    fi
  done
}

function doDevonCommandAndReturn() {
  if [ -z "${1}" ]
  then
    doFail "Command is required and can not be omitted!"
  fi
  local command_name="${1}"
  local command="${DEVON_IDE_HOME}/scripts/command/${1}"
  if [ ! -e "${command}" ]
  then
    doFail "Undefined devon command: ${1}\nNot found at ${command}."
  else
    if [ ! -x "${command}" ]
    then
      doWarning "Command ${1} is not executable. Trying to repair..."
      chmod a+x "${command}"
    fi
    shift
    # shellcheck disable=SC2086
    "${command}" ${force} ${quiet} ${debug} ${batch} "${@}"
    result=${?}
    if [ ${result} != 0 ]
    then
      doError "Command '${command_name} ${*}' failed with exit code ${result}"
      return ${result}
    fi
  fi
}

function doUpdateUrls() {
  local urls_dir="${DEVON_IDE_HOME}/urls"
  doDebug "Cloning or updating download urls"
  doGitPullOrClone "${urls_dir}" "${DEVON_URLS:-https://github.com/devonfw/ide-urls.git}"
}

# $1: the URL to download
# $2: the optional, target directory to save to
# $3: the software to download (e.g. 'java', 'mvn', 'node')
# $4: the version of the software to download
# $5: the optional edition (e.g. "enterprise" or "community")
# $6: operating system name
# $7: the optional architecture (e.g. x64 or x86_64)
# $8: the optional extension (e.g. 'tar.gz' or 'zip')
# $9: the optional filename to download to
function doDownload() {
  doDebug "doDownload ${*}"
  doLicenseAgreement
  local url="${1}"
  local target_dir="${2}"
  local software="${3}"
  local version="${4}"
  local edition="${5}"
  local os="${6}"
  local arch="${7}"
  local ext="${8}"
  local filename="${9}"
  if [ -z "${target_dir}" ]
  then
    target_dir="${DEVON_DOWNLOAD_DIR}"
  fi
  mkdir -p "${target_dir}"
  local tmp_file
  tmp_file=$(mktemp -ut "${software}-${version}.XXXXXX")
  if [ "${url}" = "" ] || [ "${url}" = "-" ]
  then
    if [ -z "${arch}" ]
    then
      arch="$(uname -m)"
    fi
    if [ "${arch}" = "x86_64" ]
    then 
      arch="x64"
    fi
    if [ -z "${os}" ]
    then
      if doIsMacOs
      then
        os="mac"
      elif doIsWindows
      then
        os="windows"
      else
        os="linux"
      fi
    fi
    edition=$(doGetSoftwareEdition "${software}")
    local latest_version
    if [ "${version}" = "latest" ]
    then
      latest_version="$(doGetLatestSoftwareVersion "${software}")"
      if [ -n "${latest_version}" ]
      then
        version="${latest_version}"
      else
        doFail "No latest version found at ${DEVON_IDE_HOME}/urls/${software}/${edition}"
      fi
    fi
    local urls_software_dir="${DEVON_IDE_HOME}/urls/${software}/${edition}/${version}"

    if [ ! -d "${urls_software_dir}" ]
    then
      doFail "No url is configured at ${urls_software_dir}"
    fi

    local url_file
    url_file="${urls_software_dir}/${os}_${arch}.urls"

    if [ ! -f "${url_file}" ]
    then
      if doIsMacOs 
      then
        if [ "${arch}" = "arm64" ]
        then
          # ARM64 (A1/A2) on Mac comes with Rosetta that can emulate x64 code, hence we can use this as fallback
          url_file="${urls_software_dir}/${os}_x64.urls"
        fi
      fi
    fi

    if [ ! -f "${url_file}" ]
    then
      url_file="${urls_software_dir}/${os}.urls"
      if [ ! -f "${url_file}" ]
      then 
        url_file="${urls_software_dir}/urls"
      fi
    fi
    if [ ! -f "${url_file}" ]
    then
      doFail "No url file found at ${urls_software_dir}"
    fi 

    local url
    declare -a urls
    while IFS= read -r url
    do
      urls[i]="${url}"
      ((++i))
    done < "${url_file}"

    # suffle urls to choose urls in random order and distribute load
    local size="${#urls[*]}"
    local rand
    local tmp
    local i
    for ((i=size-1; i>0; i--))
    do
      rand=$((RANDOM%(size+1)))
      tmp="${urls[i]}"
      urls[i]="${urls[rand]}"
      urls[rand]="${tmp}"
    done

    # download from urls, try next url on error
    for download_url in "${urls[@]}"
    do
      if [ -z "${filename}" ]
      then
        filename="${software}-${version}"
        if [ -n "${edition}" ] && [ "${edition}" != "${software}" ]
        then
          filename="${filename}-${edition}"
        fi
        if [ "${os}" != "-" ] && [ -n "${os}" ]
        then
          filename="${filename}-${os}"
        fi
        if [ -z "${ext}" ]
        then
          local urlfilename
          urlfilename="${download_url/*\//}"
          local urlfileext
          urlfileext="$(doGetExtension "${download_url}")"
          if [ "${urlfilename}" == "${urlfileext}" ] || [ "${urlfileext}" == "" ]
          then
            if doIsMacOs
            then
              ext="zip"
            elif doIsWindows
            then
              ext="zip"
            else
              ext="tgz"
            fi
          else
            ext="${urlfileext}"
          fi
        fi
        filename="${filename}.${ext}"
      fi
      doDownloadInternal "${download_url}" "${tmp_file}" "${target_dir}" "${filename}"
      local result=${?}
      if [ "${result}" = 0 ] || [ "${result}" = 255 ]
      then
        if [ -e "${url_file}.sha256" ]
        then
          local checksum
          checksum="$(cat "${url_file}".sha256)"
          doVerifyChecksums "${target_dir}"/"${filename}" "${checksum}" "${url_file}"
        else 
          if [ "${version}" != "latest" ]
          then
            doEcho "No checksum found at ${url_file}.sha256"
          else
            doWarning "No checksum found at ${url_file}.sha256"
          fi
        fi
        return ${result}
      fi
    done
    doFail "Download of ${software} in version ${version} failed after trying ${#urls[*]} url(s)."
  else
    doDownloadInternal "${url}" "${tmp_file}" "${target_dir}" "${filename}"
    result=${?}
    if [ "${result}" = 0 ] || [ "${result}" = 255 ]
    then
      local checksum
      checksum="$(cat "${DEVON_IDE_HOME}"/urls/"${software}"/"${edition}"/"${version}"/"${os}"_"${arch}".urls.sha256)"
      doVerifyChecksums "${target_dir}"/"${filename}" "${checksum}" "${url_file}"
      return "${result}"
    fi
    doFail "Failed to download ${filename} from ${1}" "${result}"
  fi
}

# $1: path of download file
# $2: verified checksum
# $3: url_file
function doVerifyChecksums() {
  local shasum="shasum -a 256"
  local download_file_path="${1}"
  local checksum="${2}"
  local url_file="${3}"
  if doIsWindows
  then
    shasum="sha256sum"
  fi
  local checksum_downloadfile
  checksum_downloadfile="$(eval "${shasum}" "${download_file_path}" | cut -d" " -f1)"
  if [ "${checksum_downloadfile}" != "${checksum}" ]
  then
    doFail "Downloaded file has the wrong checksum!\nExpected ${checksum}\nDownload ${checksum_downloadfile}\nThis could be a man-in-the-middle-attack, a download failure, or a release that has been updated afterwards.\nPlease review carefully.\nExpected checksum can be found at ${url_file}.sha256.\nActual checksum was computed via ${shasum} ${download_file_path}\nInstallation was aborted for security reasons!"
  else
    doSuccess "Checksum ${checksum_downloadfile} is correct"
  fi
}

# $1: URL to download
# $2: path to tmp-file to download to
# $3: path to download folder
# $4: optional download filename
function doDownloadInternal() {
  local url="${1}"
  local tmp_file="${2}"
  local target_folder="${3}"
  DOWNLOAD_FILENAME="${4}"
  if [ -z "${DOWNLOAD_FILENAME}" ]
  then
    DOWNLOAD_FILENAME="${url/*\//}"
  fi
  doEcho "Trying to download ${DOWNLOAD_FILENAME} from ${url}"
  local target="${target_folder}/${DOWNLOAD_FILENAME}"

  if [ -f "${target}" ] && [ -z "${force}" ]
  then
    doWarning "Artifact already exists at ${target}\nTo force update please delete the file and run again."
    return 255
  fi
  local curl_opt=""
  if [ -n "${quiet}" ]
  then
    curl_opt="--silent"
  fi
  curl ${curl_opt} -fL "${url}" -o "${tmp_file}"
  local result=${?}
  if [ "${result}" != 0 ]
  then
    doWarning "Failed to download ${url} with exit code ${result}"
    return ${result}
  else
    mv "${tmp_file}" "${target}"
    doSuccess "Download of ${DOWNLOAD_FILENAME} from ${url} succeeded."
  fi
}

# $1: filename (potentiall including absolute or relative path)
# echos the file extension
function doGetExtension() {
  local filename="${1/*\//}"
  local ext="${filename/*\./}"
  local filename_base="${filename:0:(${#filename}-${#ext}-1)}"
  if [ "${filename_base/*\./.}" = ".tar" ]
  then
    ext="tar.${ext}"
  fi
  echo "${ext}"
}

#.$@ any number of file paths
# echos the first of the given paths that does exist
function doGetFirstExistingPathOrFail() {
  local message="None of the following path(s) exists:"
  while [ -n "${1}" ]
  do
    message="${message}\n${1}"
    if [ -e "${1}" ]
    then
      echo "${1}"
      return
    fi
    shift
  done
  doFail "${message}"
}

#.$@ any number of file paths
# echos the first of the given paths that does exist
function doGetFirstExistingPath() {
  while [ -n "${1}" ]
  do
    if [ -e "${1}" ]
    then
      echo "${1}"
      return
    fi
    shift
  done
  return 1
}

# $1: the file to extract
# $2: optional folder to extract to
function doExtract() {
  local target_dir=${DEVON_IDE_HOME}/updates/extracted
  local filename=${1/*\//}
  local extracted="yes"
  rm -rf "${target_dir}"
  if [ -n "${2}" ]
  then
    target_dir="${target_dir}/${2}"
  fi
  mkdir -p "${target_dir}"
  local ext="${filename/*\./.}"
  local filename_base="${filename:0:(${#filename}-${#ext})}"
  if [ "${filename_base/*\./.}" = ".tar" ] || [ "${ext}" = ".tar" ] || [ "${ext}" = ".tgz" ] || [ "${ext}" = ".tbz2" ]
  then
    doRunCommand "tar xf '${1}' -C '${target_dir}'"
  elif [ "${ext}" = ".zip" ] || [ "${ext}" = ".jar" ]
  then
    doUnzip "${1}" "${target_dir}"
  elif [ "${ext}" = ".dmg" ]
  then
    local mount_dir="${DEVON_IDE_HOME}/updates/volume"
    mkdir -p "${mount_dir}"
    doRunCommand "hdiutil attach -quiet -nobrowse -mountpoint '${mount_dir}' '${1}'"
    doRunCommand "cp -a '${mount_dir}'/*.app '${target_dir}'"
    doRunCommand "hdiutil detach -force '${mount_dir}'"
    if [ -e "${target_dir}/Applications" ]
    then
      rm "${target_dir}/Applications"
    fi
  elif doIsInstallerExtension "${filename}"
  then
    doRunCommand "mv \"${1}\" \"${target_dir}\""
    extracted="no"
  elif [ "${ext}" = ".pkg" ]
  then
    local macos_download_file
    macos_download_file="${1}"
    mkdir "${target_dir}/~tmp/"
    xar -C "${target_dir}/~tmp/" -xf "${macos_download_file}"
    tar -C "${target_dir}" -xzvf "${target_dir}"/~tmp/*/Payload
    [ -d "${target_dir}/~tmp/" ] && rm -rf "${target_dir}/~tmp/"
  elif [ "${ext}" = ".msi" ]
  then
    local windows_download_file
    windows_download_file=$(cygpath -w "${1}")
    local windows_target_dir
    windows_target_dir=$(cygpath -w "${target_dir}")
    local downloadfile
    downloadfile="${target_dir}/$(basename "${1}")"
    msiexec //a "${windows_download_file}" //qn "TARGETDIR=${windows_target_dir}"
    [ -f "${downloadfile}" ] && rm -rf "${downloadfile}"
  else
    doFail "Unknown archive format: ${ext}. Can not extract ${1}"
  fi
  if [ "${extracted}" = "no" ]
  then
    doSuccess "Successfully moved archive ${filename} to ${target_dir}"
  else
    doSuccess "Successfully extracted archive ${filename} to ${target_dir}"
  fi
}

# $n: the executable to run (may be expaneded glob pattern(s))
function doRunFirstExecutable() {
  local installer="$1"
  while [ -n "$1" ]
  do
    doDebug "Trying to execute $1"
    if [ -x "$1" ]
    then
      doRunCommand "$1"
      return
    elif doIsWindows
    then
      local ext="${1/*\./}"
      doDebug "Detected extension ${ext}"
      if [ "${ext}" = "msi" ]
      then
        installer="$(cygpath -w "$1")"
        doRunCommand "msiexec //i '${installer}'"
        if [ "$?" = 0 ]
        then
          return
        fi
      elif [ "${ext}" = "exe" ]
      then
        doRunCommand "$1"
        return
      fi
    fi
    shift
  done
  doFail "Installation failed from ${installer}"
}

# $1: the file to unzip
# $2: target_dir
function doUnzip() {
  local zipfile="${1}"
  local target_dir="${2}"
  if ! command -v unzip &> /dev/null
  then
    doInstallWithPackageManager "apt-get install unzip" "yum install unzip" "pacman -S unzip" "emerge install unzip" "zypp install unzip" "apk add unzip" "brew install unzip"
  fi
  doRunCommand "unzip -qn '${zipfile}' -d '${target_dir}'"
}

function doInstallWithPackageManager() {
  local first  
  for installString in "${@}"
  do
    first="${installString/ */}"
    if command -v "${first}" > /dev/null
    then
      doEcho "Installing: ${installString}"
      doRunCommand "sudo ${installString}"
      return
    fi
  done
  doError "No supported package manager found on your system.\nInstallation failed: ${1}"
}

# $1: filename (e.g. ${filename})
function doIsInstallerExtension() {
  local myext="${1/*\./.}"
  if [ "${myext}" = ".exe" ] || [ "${myext}" = ".bat" ] || [ "${myext}" = ".py" ]
  then
    return
  fi
  return 255
}

# $1: absolute path of file or folder to move
# $2: optional target (e.g. "${DEVON_IDE_HOME}/software/")
# $3: backup path
function doReplaceExtractedFile() {
  if [ ! -e "${1}" ]
  then
    doFail "The file or folder to move does not exist: ${1}"
  fi
  local filename="${1/*\//}"
  local target_dir="${DEVON_IDE_HOME}"
  local target="${DEVON_IDE_HOME}/${filename}"
  local migration="${DEVON_IDE_HOME}/scripts/migration"
  if [ -n "${2}" ]
  then
    target="${2}"
    target_dir="$(dirname "${2}")"
  fi
  if [ "${target}" = "${DEVON_IDE_HOME}/scripts" ] && doIsWindows
  then
    (sleep 10;doBackup "${target}" "${3}";doRunCommand "mv '${1}' '${target}'";doRunCommand "'${migration}'") &
  else
    doBackup "${target}" "${3}"
    if [ ! -d "${target_dir}" ]
    then
      mkdir -p "${target_dir}"
    fi
    doRunCommand "mv '${1}' '${target}'"
    if [ "${target}" = "${DEVON_IDE_HOME}/scripts" ]
    then
      doRunCommand "'${migration}'"
    fi
  fi
}

# $1: source file or directory to backup
# $2: optional relative timestamp path
function doBackup() {
  if [ -e "${1}" ]
  then
    local source="${1}"
    local timestamp="${2}"
    if [ -z "${timestamp}" ]
    then
      timestamp="$(date "+%y-%m-%d")"
    fi
    local backup_dir="${DEVON_IDE_HOME}/updates/backups/${timestamp}"
    if [ -e "${backup_dir}/${source/*\//}" ]
    then
      backup_dir="${backup_dir}/$(date "+%H-%M-%S")"
    fi
    mkdir -p "${backup_dir}"
    doEcho "Creating backup by moving existing ${source} to ${backup_dir}"
    mv "${source}" "${backup_dir}/" || doFail "Failed to move ${source} to ${backup_dir}.\nMost probably this is a problem of windows file locks. In such case please terminate all processes locking the files and retry the operation.\nPlease visit https://github.com/devonfw/ide/blob/master/documentation/how-to-unlock-files.asciidoc for more information."
  fi
}

# $1: path of the extracted name to install (move to target)
# $2: optional target (e.g. "${DEVON_IDE_HOME}/software/")
# $3: backup path
# $4-$N: contents of $1 ($1/* so all files in the folder of $1 after globbing)
function doReplaceExtractedSkipSingleFolder() {
  local source_path="${1}"
  local target_path="${2}"
  local backup_path="${3}"
  shift 3
  local path="${1}"
  local basename="${path/*\//}"
  if [ "${#*}" = 1 ] && [ "${path%.app}" = "${path}" ] && [ -d "${path}" ] && [ "${basename}" != "Contents" ] && [ "${basename}" != "bin" ]
  then
    doDebug "Changing source directory from ${source_path} to ${1} due to single folder."
    source_path="${1}"
    doReplaceExtractedSkipSingleFolder "${source_path}" "${target_path}" "${backup_path}" "${source_path}"/*
  else
    doReplaceExtractedFile "${source_path}" "${target_path}" "${backup_path}"
    [ -d "${source_path}" ] && rm -rf "${source_path}"
  fi
}

# $1: path of the extracted name to install (move to target)
# $2: target (e.g. "${DEVON_IDE_HOME}/software/")
function doReplaceExtracted() {
  local backup_dir
  backup_dir="$(date +"%y-%m-%d")"
  if [ "${2}" = "${DEVON_IDE_HOME}" ]
  then
    for extracted_file in "${1}"/*
    do
      if [ -e "${extracted_file}" ]
      then
        if [ "${extracted_file/*\//}" = "workspaces" ]
        then
          doEcho "as the target already exists, omitting ${extracted_file}"
        else
          doReplaceExtractedFile "${extracted_file}" "${2}/${extracted_file/*\//}" "${backup_dir}"
        fi
      fi
    done
  else
    doReplaceExtractedSkipSingleFolder "${1}" "${2}" "${backup_dir}" "${1}"/*
  fi
}

# $1: URL (to artifactId)
function doMavenGetLatestVersion() {
  doEcho "Trying to determine the latest available version from ${1}/maven-metadata.xml"
  LATEST_VERSION="$(curl -fs "${1}/maven-metadata.xml" | grep latest | sed "s/.*<latest>\([^<]*\)<\/latest>.*/\1/")"
  result=${?}
  if [ "${result}" != 0 ] || [ -z "${LATEST_VERSION}" ]
  then
    doFail "Failed to determine the latest version from ${1}/maven-metadata.xml.\nCheck that 'curl' is installed (curl -v) and you have internet connection available." ${result}
  fi
}

# $1: version
function doIsDevVersion() {
  [ "${1}" = "dev-SNAPSHOT" ] || [ "${1}" = "0-SNAPSHOT" ]
}

# ${1}-${n-1}: array
# ${n}: prefix to check if array contains element starting with
function doArrayContainsItemWithPrefix() {
  local n
  local element
  n=${#}
  element="${!n}"
  for ((i=1; i < ${#}; i++)) {
    if [[ "${!i}" == ${element}* ]]
    then
      return 0
    fi
  }
  return 1
}

# $1: java package
# $2: optional groupId
# $3: optional artifactId 
function doMavenArchetype() {
  if [ -z "${1}" ]
  then
    doFail "Missing arguments for doMavenArchetype ${*}"
  fi
  local old_args
  old_args="${*}"
  local target_package
  local target_group_id
  local target_artifact_id
  declare -a target_args
  while [ -n "${1}" ]
  do
    if [ "${1:0:1}" = "-" ]
    then
      target_args+=("${1}")
    else
      if [ -z "${target_package}" ]
      then
        target_package="${1}"
      elif [ -z "${target_group_id}" ]
      then
        target_group_id="${1}"
      elif [ -z "${target_artifact_id}" ]
      then
        target_artifact_id="${1}"
      else
        doFail "Too many args: ${*}"
      fi
    fi
    shift
  done
  if [ -n "${target_package}" ]
  then
    # package
    if doArrayContainsItemWithPrefix "${target_args[@]}" "-Dpackage="
    then
      doFail "Duplicate package for archetype: ${old_args}"
    else
      target_args+=("-Dpackage=${target_package}")
    fi
    # artifactId
    if doArrayContainsItemWithPrefix "${target_args[@]}" "-DartifactId="
    then
      if [ -n "${target_artifact_id}" ]
      then
        doFail "Duplicate artifactId for archetype: ${old_args}"
      fi
    else
      if [ -z "${target_artifact_id}" ]
      then
        target_artifact_id="${target_package/*\./}"
      fi
      target_args+=("-DartifactId=${target_artifact_id}")
    fi
    # groupId
    if doArrayContainsItemWithPrefix "${target_args[@]}" "-DgroupId="
    then
      if [ -n "${target_group_id}" ]
      then
        doFail "Duplicate groupId for archetype: ${old_args}"
      fi
    else
      if [ -z "${target_group_id}" ]
      then
        local artifact_id="${target_package/*\./}"
        if [ "$artifact_id" = "${target_package}" ]
        then
          target_group_id="${target_package}"
        else
          target_group_id="${target_package:0:(${#target_package}-${#artifact_id}-1)}"
        fi
      fi
      target_args+=("-DgroupId=${target_group_id}")
    fi
  fi
  if ! doArrayContainsItemWithPrefix "${target_args[@]}" "-Dversion="
  then
    target_args+=("-Dversion=1.0.0-SNAPSHOT")
  fi
  if ! doArrayContainsItemWithPrefix "${target_args[@]}" "-DarchetypeVersion="
  then
    doMavenGetLatestVersion "https://repo.maven.apache.org/maven2/${ARCHETYPE_GROUP_ID//.//}/${ARCHETYPE_ARTIFACT_ID}"
    target_args+=("-DarchetypeVersion=${LATEST_VERSION}")
  fi
  if [ -z "${target_artifact_id}" ]
  then
    for ((i=1; i < ${#}; i++)) {
      if [[ "${!i}" == -DartifactId=* ]]
      then
        target_artifact_id="${!i:13}" # "-DartifactId=" is 13 chars long
      fi
    }
  fi
  if [ -e "${target_artifact_id}" ]
  then
    doFail "Project ${target_artifact_id} already exists at ${PWD}"
  fi
  doDevonCommand mvn -B archetype:generate "-DarchetypeGroupId=${ARCHETYPE_GROUP_ID}" "-DarchetypeArtifactId=${ARCHETYPE_ARTIFACT_ID}" -DinteractiveMode=false "${target_args[@]}"
}

# $1: target path (e.g. "${DEVON_IDE_HOME}/software/")
# $2: URL (to groupId)
# $3: artifactId
# $4: version ('LATEST' for the most recent version)
# $5: suffix (e.g. '-sources.jar')
# $6: currentVersion
function doUpgradeMavenArtifact() {
  local target_path="${1}"
  local url="${2}"
  local artifact_id="${3}"
  local target_version="${4}"
  local suffix="${5}"
  local current_version="${6}"
  doLicenseAgreement
  if [ -d "${target_path}/.git" ]
  then
    doEcho "Found git repository ${target_path} - updating via git"
    doGitPullOrClone "${target_path}"
    return ${?}
  fi
  url="${url}/${artifact_id}"
  local repository="${DEVON_SOFTWARE_REPOSITORY}"
  if [ "${current_version}" = "0" ] && ! doIsForce
  then
    echo "Current version of ${artifact_id} is 0. Update is aborted. Use force (-f) to enforce update."
    return 1
  fi
  doEchoStep "Software Update of ${artifact_id}"
  doEcho "Updating ${target_path} from ${url}"
  if [ "${target_version}" = "LATEST" ]
  then
    doMavenGetLatestVersion "${url}"
    target_version="${LATEST_VERSION}"
    repository="-"
  fi
  if [ -n "${current_version}" ] && [ "${current_version}" != "0" ]
  then
    doVersionCompare "${target_version}" "${current_version}"
    result=${?}
    if [ "${result}" = 0 ]
    then
      doEcho "The ${artifact_id} package is already at the correct version ${target_version}"
      return 1
    else
      doEcho "You are using version ${current_version} of ${artifact_id}"
      doEcho "The new version to install is ${target_version}"
      if [ "${result}" = 2 ] && [ "${4}" = "LATEST" ]
      then
        doEcho "You are using a newer version than the latest release version."
        doEcho "Hence there is nothing to update."
        doEcho "Seems as you are an active devonfw developer. Thanks for contributing!"
        return 1
      fi
    fi
  fi
  if [[ "${target_version}" =~ alpha|beta|rc|pre|test ]]
  then 
    doAskToContinue "Latest version seems unstable: ${target_version}\nAre you sure you want to install this version?"
  fi
  url="${url}/${target_version}/${artifact_id}-${target_version}${suffix}"
  doInstall "${artifact_id}" "${target_version}" "" "" "${1}" "-" "" "${repository}" "${url}"
}

# $1: target
# $2: source
function doMoveGlobSafe() {
  if [ -e "${2}" ]
  then
    doEcho "Moving ${2} to ${1}"
    mv "${2}" "${1}"
  fi
}

# $1: absolute target path
# $2: URL (may be URL#branch)
function doGitPullOrClone() {
  local dir="${1}"
  local url="${2}"
  local git_opts=""
  if [ -d "${dir}/.git" ]
  then
    pushd "${dir}" > /dev/null || exit 255
    if ! doIsDebug
    then
      git_opts="-q"
    fi
    local remotes
    remotes="$(git remote)"
    local message="Can not update git repository: ${dir}\n"
    if [ -n "${remotes}" ]
    then
      git pull ${git_opts}
      local result="$?"
      if [ "${result}" != 0 ]
      then
        local branch
        branch="$(git branch --show-current)"
        local branchRemoteRef
        branchRemoteRef="$(git ls-remote --heads origin "${branch}" 2>&1)"
        if [ -z "${branchRemoteRef}" ]
        then
          message="${message}It seems you are working on a local branch. For testing, you may continue...\n"
        else
          doFail "${message}See above error for details - check your network connectivity and retry."
        fi
      fi
      popd > /dev/null || exit 255 
      if [ "${result}" = 0 ]
      then
        return
      fi
    else
      message="${message}This is a local git repo with no remote - if you did this for testing, you may continue...\n"
    fi
    doAskToContinue "${message}Do you want to ignore the problem and continue anyhow?"
  else
    if [ -z "${url}" ]
    then
      doFail "Not a git repository: ${dir}"
    else
      mkdir -p "${dir}"
      pushd "${dir}" > /dev/null || exit 255 
      if doIsQuiet
      then
        git_opts="-q"
      else
        doEcho "Cloning git repositroy from ${url}"
      fi
      local branch="${url/*#/}"
      url="${url%#*}"
      doRunCommand "git clone ${git_opts} --recursive '${url}' --config core.autocrlf=false ."
      if [ "${branch}" != "${url}" ]
      then
        doRunCommand "git checkout ${git_opts} ${branch}"
      fi
      popd > /dev/null || exit 255 
    fi
  fi
}

# $1: URL
# $2: resolved version
# $3: resolved os
# $4: resolved arch
# $5: optional software edition
function doResolveDownloadUrl() {
  echo "${1}"
}

# $1: name of software
# $2: version of software
# $3: optional silent flag ('silent' to suppress output if already up-to-date or empty for version output)
# $4: optional edition (e.g. "enterprise" or "community")
# $5: optional absolute target path where to install
# $6: optional OS indicator ('-' if OS independent)
# $7: optional to ignore extracting downloaded files (use 'noUnpack' or leave empty to extract)
# $8: optional software repository
# $9: optional download URL
function doInstall() {
  doDebug "doInstall ${*}"
  local software="${1}"
  local version="${2}"
  local silent="${3}"
  local edition="${4}"
  local target_path="${5}"
  local os="${6}"
  local noUnpack="${7}"
  local repository="${8}"
  local url="${9}"
  if [ -z "${target_path}" ]
  then
    target_path="${DEVON_IDE_HOME}/software/${software}"
  fi
  local ext
  local arch
  local download_dir="${DEVON_DOWNLOAD_DIR}"
  if [ -z "${software}" ]
  then
    doFail "Missing software argument for doInstall: ${*}"
  fi
  local result=0
  if [ "${url/.git/}" != "${url}" ]
  then
    doGitPullOrClone "${target_path}" "${url}"
    return
  fi
  if [ -z "${version}" ]
  then
    doUpdateUrls
    version=$(doGetLatestSoftwareVersion "${software}")
    doDebug "Resolved latest version of ${software} to ${version}"
  elif [ "${version:${#version}-1}" = "*" ]
  then
    doUpdateUrls
    doDebug "Resolving version prefix ${version}"
    edition=$(doGetSoftwareEdition "${software}")
    resolved_version=$(doGetLatestSoftwareVersion "${software}" "${version}")
    if [ -n "${resolved_version}" ]
    then
      doDebug "Resolved version prefix ${version} to ${resolved_version}"
      version="${resolved_version}"
    else
      doFail "Could not resolve version prefix ${version} : no matching version found in ${DEVON_IDE_HOME}/urls/${software}/${edition}/"
    fi
  fi
  local version_file="${target_path}/.devon.software.version"
  local current_version=
  if [ -e "${version_file}" ]
  then
    current_version="$(cat "${version_file}")"
    if [ "${current_version}" == "${version}" ]
    then
      if [ -z "${silent}" ]
      then
        doEcho "Version ${version} of ${software} is already installed at ${target_path}."
        if [ -n "${TOOL_VERSION_COMMAND}" ] && [ "${TOOL_VERSION_COMMAND}" != "-" ] && ! doIsQuiet
        then
          doRunCommand "${TOOL_VERSION_COMMAND}" "verify installation of ${software}"
        fi
      fi
      return 1
    else
      doEcho "Updating ${software} from version ${current_version} to version ${version}..."
    fi
  fi
  local dir="${target_path/*\//}"
  doRunCommand "mkdir -p '${target_path%/*}'"
  local repo="default"
  if [ -z "${repository}" ]
  then
    repository="${DEVON_SOFTWARE_REPOSITORY}"
  fi
  if [ -n "${repository}" ] && [ "${repository}" != "-" ] && [ -n "${version}" ]
  then
    local filename="${software}-${version}"
    if [ "${os}" != "-" ]
    then
      if [ -z "${os}" ]
      then
        if doIsMacOs
        then
          filename="${filename}-mac"
        elif doIsWindows
        then
          filename="${filename}-windows"
        else
          filename="${filename}-linux"
        fi
      fi
    fi
    ext="tgz"
    url="${repository}/${software}/${version}/${filename}.tgz"
    result=1
    repo="${repository/*:\/\//}"
    local host="${repo/\/*/}"
    repo="${repo:${#host}}"
    host="${host/:/_}"
    repo="${host}/${repo//[^A-Za-z0-9._-]/_}"
    download_dir="${download_dir}/${repo}"
  fi
  doEcho "Starting installation of ${software} in version ${version} to ${target_path}"
  if [ -L "${target_path}" ]
  then
    doEcho "Deleting old installation as it is a symlink: ${target_path}"
    rm "${target_path}"
  fi
  local install_path="${target_path}"
  if [ "${target_path}" = "${DEVON_IDE_HOME}/software/${dir}" ] || [ "${target_path}" = "${DEVON_IDE_HOME}/software/extra/${dir}" ] && [ -n "${DEVON_SOFTWARE_PATH}" ]
  then
    install_path="${DEVON_SOFTWARE_PATH}/${repo}/${software}/${version}"
    version_file="${install_path}/.devon.software.version"
  fi
  if [ ! -d "${install_path}" ] || [ "${install_path}" == "${target_path}" ]
  then
    doDownload "${url}" "${download_dir}" "${software}" "${version}" "${edition}" "${os}" "${arch}" "${ext}"
    doDebug "Received download file ${DOWNLOAD_FILENAME}"
    if [ -n "${noUnpack}" ]
    then
      doDebug "Download shall not be extracted, hence copying ${DOWNLOAD_FILENAME} to ${install_path}"
      doRunCommand "mkdir -p '${install_path}'"
      doRunCommand "cp '${download_dir}/${DOWNLOAD_FILENAME}' '${install_path}'"
    else
      doExtract "${download_dir}/${DOWNLOAD_FILENAME}" "${dir}"
      doReplaceExtracted "${DEVON_IDE_HOME}/updates/extracted/${dir}" "${install_path}"
    fi
    if [ "${install_path}" != "${DEVON_IDE_HOME}" ]
    then
      echo "${version}" > "${version_file}"
    fi
    doSuccess "Successfully installed ${software}"
  else
    doEcho "Software ${software} seems to be already available in ${install_path}"
    result=1
    current_version=
    if [ -e "${version_file}" ]
    then
      current_version="$(cat "${version_file}")"
    fi
    if [ "${current_version}" != "${version}" ]
    then
      doFail "Installation corrupt at ${install_path}\nDetected version: ${current_version}\nExpected version: ${version}"
    fi
  fi
  if [ "${install_path}" != "${target_path}" ]
  then
    doBackup "${target_path}"
    doEcho "Linking ${install_path} to ${target_path}"
    if doIsWindows
    then
      doRunCommand "cmd //c 'mklink /d /j $(cygpath -w "${target_path}") $(cygpath -w "${install_path}")'"
      if [ "${?}" != 0 ]
      then
        doFail "Creating symbolic links is not supported on your windows operating system.\nPlease read the documentation how to properly configure your OS or disable this feature by removing the DEVON_SOFTWARE_PATH variable."
      fi
    else
      ln -s "${install_path}" "${target_path}"
    fi
  fi

  # macos workaround
  if [ ! -d "${target_path}/bin" ] && doIsMacOs
  then
    local contents="Contents"
    if ! [ -d "${target_path}/${contents}" ]
    then
      pushd "${target_path}" > /dev/null || exit 255
      # doGetFirstExistingPath does not have options
      # shellcheck disable=SC2035
      contents="$(doGetFirstExistingPath *.app/Contents)"
      popd > /dev/null || exit 255 
    fi
    if [ -n "${contents}" ] && [ -d "${target_path}/${contents}" ]
    then
      doDebug "Found MacOS app in ${target_path}/${contents}"
      local app_folder="-"
      if [ -d "${target_path}/${contents}/Resources/app/bin" ]
      then
        app_folder="Resources/app"
      else
        local folder
        while IFS= read -r -d '' folder
        do
          folder="${folder/*\//}"
          doDebug "Checking app sub-folder ${folder}"
          if [ "${folder}" != "Contents" ] && [ "${folder}" != "Resources" ] && [ "${folder}" != "bin" ] && [ "${folder:0:1}" != "_" ]
          then
            if [ -d "${target_path}/${contents}/${folder}/bin" ]
            then
              app_folder="${folder}"
              doDebug "App folder with bin detected as ${app_folder}"
              break
            else
              doDebug "Looking for executable in ${folder}"
              local file
              while IFS= read -r -d '' file
              do
                if [ -x "${file}" ] && [ "${file:(-4)}" != ".txt" ]
                then
                  app_folder="${folder/*\//}"
                  doDebug "App folder with executable detected as ${app_folder}"
                  break
                fi
                done < <(find "${target_path}/${contents}/${folder}/" -maxdepth 1 -type f -print0)
            fi
          fi
        done < <(find "${target_path}/${contents}" -maxdepth 1 -type d -print0)
      fi
      if [ "${app_folder}" != "-" ] && [ -d "${target_path}/${contents}/${app_folder}" ]
      then
        doEcho "Creating symlink as workaround for ${software} on MacOS"
        local target_software_macos=${target_path%\/*}/macos
        if [ ! -d "${target_software_macos}" ]
        then
          mkdir -p "${target_software_macos}"
        fi
        local target_software_software=${target_software_macos}/${dir}
        doRunCommand "rm -rf '${target_software_software}'"
        doRunCommand "mv '${target_path}' '${target_software_software}'"
        doRunCommand "ln -sf 'macos/${dir}/${contents}/${app_folder}' '${target_path}'"
        doRunCommand "cp '${target_software_software}/.devon.software.version' '${target_path}'"
      fi
    fi
  fi
  if [ "${target_path}" = "${DEVON_IDE_HOME}/software/${dir}" ]
  then
    doExtendPath "${target_path}"
  fi
  if [ -n "${TOOL_VERSION_COMMAND}" ] && [ "${TOOL_VERSION_COMMAND}" != "-" ] && ! doIsQuiet
  then
    doRunCommand "${TOOL_VERSION_COMMAND}" "verify installation of ${software}"
  fi

  doCheckSoftwareSecurityVersion "${software}" "${version}" "${edition}"
  return ${result}
}

# $1: software folder to add to path
function doExtendPath() {
  local software_path="${1}"
  if [ -d "${software_path}/bin" ]
  then
    export PATH="${software_path}/bin:${PATH}"
  else
    export PATH="${software_path}:${PATH}"
  fi
  doQuestion "The software ${software_path/*\//} has been added. You need to rerun 'devon' command without arguments or restart your terminal to update your PATH so the newly installed software will be found."
}

# $1: templates path
# $2: workspace path
# $3: configurator mode (-u / -r / -x)
function doConfigureWorkspace() {
  if [ ! -d "${1}" ]
  then
    doFail "Could not find templates path at ${1}"
  fi
  if [ ! -d "${2}" ]
  then
    doFail "Could not find workspace at ${2}"
  fi
  local replacement_patterns_path=${1}/replacement-patterns.properties
  if [ ! -e "${replacement_patterns_path}" ]
  then
    touch "${replacement_patterns_path}"
  fi
  doRunConfigurator "com.devonfw.tools.ide.configurator.Configurator" -t "${1}" -w "${2}" -v "${replacement_patterns_path}" "${3}"
  local result=${?}
  local action="changed"
  if [ "${3}" = "-u" ]
  then
    local action="updated"
  elif [ "${3}" = "-i" ]
  then
    action="merged back to settings"
  elif [ "${3}" = "-x" ]
  then
    action="merged back to settings (including new properties)"
  fi
  if [ ${result} = 0 ]
  then
    doSuccess "Your workspace ${WORKSPACE} has been ${action}"  
  else
    doFail "Your workspace ${WORKSPACE} could not be ${action}"
  fi
}

function doRunConfigurator() {
  local classpath=""
  for file in "${DEVON_IDE_HOME}/scripts/lib"/*.jar
  do
    if [ -z "${classpath}" ]
    then
      classpath="${file}"
    else
      classpath="${classpath}:${file}"
    fi
  done
  doRunCommand "java -cp '${classpath}' ${*}" "Configure workspace"
}

# $1: name of ide
function doCreateIdeScript() {
  local script_file="${DEVON_IDE_HOME}/${1}-${WORKSPACE}"
  local script_data
  if doIsWindows
  then
    script_data="@echo off\r\npushd %~dp0\r\ncd workspaces/${WORKSPACE}\r\ncall devon.bat ${1}\r\npopd"
    script_file="${script_file}.bat"
  else
    script_data="#\!/usr/bin/env bash\ncd \$(dirname \"\${0}\")\ncd workspaces/${WORKSPACE}\nsource ${DEVON_IDE_HOME}/scripts/devon ${1}"
  fi
  if [ ! -x "${script_file}" ]
  then
    echo -e "${script_data}" > "${script_file}"
    chmod a+x "${script_file}"
    doSuccess "Created script ${script_file}"
  fi
}

# $1: version1
# $2: version2
# returns 0 if equal, 1 if $1 > $2, 2 if $1 < $2
function doVersionCompare() {
  if [ "${1}" = "${2}" ]
  then
    return 0
  fi
  local v1="${1}."
  local v2="${2}."
  while [ -n "${v1}" ] || [ -n "${v2}" ]
  do
    local s1="${v1/[.-]*/}"
    local s2="${v2/[.-]*/}"
    if [ "${s1}" != "${s2}" ]
    then
      local p1="${v1/[^0-9]*/}"
      local p2="${v2/[^0-9]*/}"
      local n1="${p1}"
      local n2="${p2}"
      if [ -z "${n1}" ]
      then
        n1=0
      fi
      if [ -z "${n2}" ]
      then
        n2=0
      fi
      if [ "${n1}" -gt "${n2}" ]
      then
        return 1
      elif [ "${n1}" -lt "${n2}" ]
      then
        return 2
      else
        if [ "${s1}" = "${s2/-SNAPSHOT/}" ]
        then
          return 1
        elif [ "${s2}" = "${s1/-SNAPSHOT/}" ]
        then
          return 2
        else
          local r1="${s1:${#p1}}"
          local r2="${s2:${#p2}}"
          n1="${r1//[^0-9]/}"
          n2="${r2//[^0-9]/}"
          local x1="${r1:0:(${#r1}-${#n1})}"
          local x2="${r2:0:(${#r2}-${#n2})}"
          x1="${x1//[-_+*]/}"
          x2="${x2//[-_+*]/}"
          if [ "${x1}" = "${x2}" ]
          then
            if [ -z "${n1}" ]
            then
              n1=0
            fi
            if [ -z "${n2}" ]
            then
              n2=0
            fi
            if [ "${n1}" -gt "${n2}" ]
            then
              return 1
            elif [ "${n1}" -lt "${n2}" ]
            then
              return 2
            fi
          else
            # assuming ascii infix (alpha,beta,etc.) is less than nothing
            if [ -z "${x1}" ]
            then
              return 1
            elif [ -z "${x2}" ]
            then
              return 2
            fi
            # assuming alphabetic order fits: alpha < beta < pre < rc
            if [ "${x1}" \> "${x2}" ]
            then
              return 1
            else
              return 2
            fi
          fi
          if [ "${s1}" \> "${s2}" ]
          then
            return 1
          else
            return 2
          fi
        fi
      fi
    fi
    v1=${v1#*[.-]}
    v2=${v2#*[.-]}
  done
  return 0
}

#$1: version to increase
function doGetNextVersion() {
  local version="${1}"
  local suffix="${version##*[0-9]}"
  local prefix=""
  local last=""
  local next=""
  local begin="${version:0:(${#version}-${#suffix})}"
  if [ -n "${begin}" ]
  then
    local i
    for ((i=(${#begin}-1); i>0; i=i-1))
    do
      if [[ ! "${begin:(${i}):1}" =~ [0-9] ]]
      then
        i=$((i+1))
        break
      fi
    done
    prefix="${begin:0:(${i})}"
    last="${begin:(${i}):(${#begin}-${i})}"
    next=$((last+1))
    # https://github.com/devonfw/ide/issues/427
    if [ "${#last}" -gt "${#next}" ]
    then
      next="${last:0:(${#last}-${#next})}${next}"
    fi
  fi
  echo "${prefix}${next}${suffix}"
}

function doIsMacOs() {
  if [ "${OSTYPE:0:6}" = "darwin" ]
  then
    return
  fi
  return 255
}

function doIsWindows() {
  if [ "${OSTYPE}" = "cygwin" ] || [ "${OSTYPE}" = "msys" ]
  then
    return
  fi
  return 255
}

# $1: prefic to check
# $2: string potentially containing the prefix
function doIsPrefix() {
  case "${2}" in
  "${1}"*)
    return 0;;
  esac
  return 255
}

# $1: dirctory
function doIsEmptyDirectory() {
  local dir="${1}"
  if [ ! -d "${dir}" ] || [ -z "$(find "${dir}" -maxdepth 0 -empty)" ]
  then
    return 1
  fi
}

function doIsPackageJsonContainingScript() {
  doDebug "Checking if package.json contains script section named $1"
  if sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/§/g' package.json | tr -d '\r' | grep -q "[\"']scripts[\"']\s*:\s*{\s*§.*[\"']${1}[\"']\s*:"
  then
    return 0
  else
    doEcho "No build script is present in package.json - skipping to run build script."
    return 255
  fi
}

# use homebrew (MacOS) to install software
function doBrewInstall() {
  if command -v brew &> /dev/null
  then
    doRunCommand "brew install ${*}"
  else
    doFail "Homebrew is required to install ${*}. Please install it manually from https://brew.sh/ and rerun your command."
  fi
}

# Ensures that Windows WSL is properly available.
function doRequireWsl() {
  local error
  if ! command -v wsl &> /dev/null
  then 
    error="WSL 2 is not installed.\nPlease install WSL 2."
  elif wsl -l > /dev/null
  then
    return
  else
    error="WSL 2 is disabled or no linux distributions found in WSL.\nPlease ensure WSL is enabled and a proper linux distribution is installed in WSL."
  fi
  doFail "${error}\nTo fix this follow these instructions:\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10"
}

# $1: software
# $2: version command
# $3: commandlet name
function doGetSoftwareVersion() {
  local software="${1}"
  local version_cmd="${2}"
  local commandlet="${3}"
  local software_folder="${DEVON_IDE_HOME}/software/${software}"
  if [ ! -d "${software_folder}" ]
  then
    software_folder="${DEVON_IDE_HOME}/software/extra/${software}"
    if [ ! -d "${software_folder}" ]
    then
      local software_cmd="${commandlet}"
      if [ "${commandlet}" = "cobigen" ]
      then
        software_cmd="cg"
      fi
      if ! command -v "${software_cmd}" &> /dev/null
      then
        doFail "Software ${software} is not installed.\nUse 'devon ${commandlet} setup' to install."
      fi
    fi
  fi
  local version_file="${software_folder}/.devon.software.version"
  if [ -e "${version_file}" ]
  then
    doEcho "The version of ${software} that has been installed by devonfw-ide was:"
    cat "${version_file}"
  fi
  if [ "${version_cmd}" != "-" ] && ! doIsQuiet
  then
    doRunCommand "${version_cmd}" "verify installation of ${software}"
  fi
}

# $1: software
function doGetSoftwareEdition() {
  local software="${1}"
  local editionVar
  editionVar="$(echo "${software/-/_}" | awk '{print toupper($0)}')_EDITION"
  local edition
  edition="${!editionVar}"
  if [ -z "${edition}" ]
  then
    edition="${software}"
  fi
  echo "${edition}"
}

# $1: software
# $2: optional prefix
function doGetLatestSoftwareVersion() {
  local software="${1}"
  local prefix="${2}"
  local edition
  local version
  edition=$(doGetSoftwareEdition "${software}")
  if [ -z "${prefix}" ]
  then
    version="$(find "${DEVON_IDE_HOME}"/urls/"${software}"/"${edition}" -mindepth 1 -maxdepth 1 -print | awk -F'/' '{print $NF}' | sort -rV | head -1)"
  else
    prefix="${prefix:0:${#prefix}-1}"
    prefix="${prefix/./[.]}"
    version="$(find "${DEVON_IDE_HOME}"/urls/"${software}"/"${edition}" -mindepth 1 -maxdepth 1 -print | awk -F'/' '{print $NF}' | grep "^${prefix}" | sort -rV | head -1)"
  fi
  echo "${version}"
} 

# $1: software
# $2: selected version
# $3: commandlet name
function doSetSoftwareVersion() {
  local software="${1}"
  local version="${2}"
  local commandlet="${3}"
  local edition
  if [ -n "${version}" ]
  then
    if [ "${version}" = "latest" ]
    then
      doUpdateUrls
      version=$(doGetLatestSoftwareVersion "${software}")
    fi
    local software_version_variable="${software}"
    software_version_variable="$(echo "${software_version_variable}" | awk '{print toupper($0)}')_VERSION"
    local devon_properties="${DEVON_IDE_HOME}/settings/devon.properties"
    grep -v "${software_version_variable}" "${devon_properties}" > "${devon_properties}.tmp"
    mv "${devon_properties}.tmp" "${devon_properties}"
    echo "${software_version_variable}=${version}" >> "${devon_properties}"
    doEchoInteraction "${software_version_variable}=${version} has been set in ${devon_properties}\nTo install that version call the following command:\ndevon ${commandlet} setup"
  else
    doError "You have to specify the version you want to set."
  fi
}

# $1: software
function doListSoftwareVersions() {
  local software="${1}"
  local edition
  doUpdateUrls
  edition=$(doGetSoftwareEdition "${software}")
  local versions_path="${DEVON_IDE_HOME}/urls/${software}/${edition}"
  declare -a versions
  versions=("$(find "${versions_path}" -mindepth 1 -maxdepth 1 -print | awk -F'/' '{print $NF}' | sort -rV)")
  local anz_versions
  anz_versions="$(echo "${versions[@]}" | wc -w )"
  if [ ! -d "${versions_path}" ]
  then
    doError "No versions available at ${versions_path}"
  else
    echo "${versions[@]}" | head -20 | pr -4 -t -s | column -t
    if [ "${anz_versions}" -ge 20 ]
    then
      doEcho "Only the 20 latest versions are displayed."
      doAskToContinue "Do you want to see all versions?"
      echo "${versions[@]}" | less
    fi
  fi
}

# $@: CLI args
# returns 0 if a standard option was detected and handled, 255 otherwise (regular argument to be handeled by CLI parser)
function doParseOption() {
  if [ "${1}" = "--" ]
  then
    return 1
  elif [ "${1}" = "-b" ] || [ "${1}" = "--batch" ]
  then
    batch="${1}"
    return
  elif [ "${1}" = "-f" ] || [ "${1}" = "--force" ]
  then
    force="${1}"
    return
  elif [ "${1}" = "-d" ] || [ "${1}" = "--debug" ]
  then
    debug="${1}"
    return
  elif [ "${1}" = "-q" ] || [ "${1}" = "--quiet" ]
  then
    quiet="${1}"
    return
  elif [ "${1}" = "version" ]
  then
    if [ -n "${TOOL_VERSION_COMMAND}" ]
    then
      if [ "${2}" = "list" ]
      then
        doListSoftwareVersions "${0/*\//}"
        exit
      elif [ "${2}" = "set" ]
      then
        doSetSoftwareVersion "${0/*\//}" "${3}" "${0/*\//}"
        exit
      elif [ "${2}" = "get" ] || [ -z "${2}" ]
      then
        doGetSoftwareVersion "${0/*\//}" "${TOOL_VERSION_COMMAND}" "${0/*\//}"
        exit
      fi
    fi
    doFail "Unknown argument(s): ${*}"
  fi
  return 255
}
